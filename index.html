<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PCAP-NG IP Analyzer</title>
    <link rel="stylesheet" href="src/styles.css">
</head>
<body>
    
    <input type="file" id="fileInput" accept=".pcapng,.pcap" style="display: none;">
    <div class="main-container">
        <div class="globe-container">
        <div id="globe-background"></div>
        <div id="globe"></div>
        <div id="progressContainer" style="display: none;">
            <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="progressText" class="loading">Starting...</div>
        </div>
        <div id="results"></div>
        </div>
        <div class="side-panel-container"></div>
    </div>

     Load libraries 
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
     Load AmCharts 
    <script src="https://cdn.amcharts.com/lib/5/index.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/map.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/geodata/worldLow.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/themes/Animated.js"></script>

     Load your existing scripts 
    <script type="module" src="src/app.js"></script>
    <script src="src/side-panel.js"></script>
    <script src="src/viewport-manager.js"></script>

    <div id="textureStatus" style="display: none; position: fixed; bottom: 20px; right: 20px; background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 5px;"></div>

     Create a simple OGL-like API for our terminal 
    <script>
        // Simple WebGL wrapper that mimics OGL API
        window.OGL = {
            Renderer: class {
                constructor({ dpr = 1 } = {}) {
                    this.canvas = document.createElement('canvas');
                    this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
                    this.dpr = dpr;
                    
                    if (!this.gl) {
                        throw new Error('WebGL not supported');
                    }
                }
                
                setSize(width, height) {
                    this.canvas.width = width * this.dpr;
                    this.canvas.height = height * this.dpr;
                    this.canvas.style.width = width + 'px';
                    this.canvas.style.height = height + 'px';
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                }
                
                render({ scene }) {
                    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
                    if (scene && scene.render) {
                        scene.render(this.gl);
                    }
                }
            },
            
            Program: class {
                constructor(gl, { vertex, fragment, uniforms = {} }) {
                    this.gl = gl;
                    this.uniforms = {};
                    
                    // Create shader program
                    const vertexShader = this.createShader(gl.VERTEX_SHADER, vertex);
                    const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragment);
                    
                    this.program = gl.createProgram();
                    gl.attachShader(this.program, vertexShader);
                    gl.attachShader(this.program, fragmentShader);
                    gl.linkProgram(this.program);
                    
                    if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                        console.error('Program link error:', gl.getProgramInfoLog(this.program));
                    }
                    
                    // Set up uniforms
                    Object.keys(uniforms).forEach(name => {
                        this.uniforms[name] = {
                            location: gl.getUniformLocation(this.program, name),
                            ...uniforms[name]
                        };
                    });
                }
                
                createShader(type, source) {
                    const shader = this.gl.createShader(type);
                    this.gl.shaderSource(shader, source);
                    this.gl.compileShader(shader);
                    
                    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                        console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
                    }
                    
                    return shader;
                }
            },
            
            Mesh: class {
                constructor(gl, { geometry, program }) {
                    this.gl = gl;
                    this.geometry = geometry;
                    this.program = program;
                }
                
                render(gl) {
                    gl.useProgram(this.program.program);
                    
                    // Update uniforms
                    Object.keys(this.program.uniforms).forEach(name => {
                        const uniform = this.program.uniforms[name];
                        if (uniform.location && uniform.value !== undefined) {
                            if (uniform.value.constructor === Float32Array) {
                                if (uniform.value.length === 2) {
                                    gl.uniform2fv(uniform.location, uniform.value);
                                } else if (uniform.value.length === 3) {
                                    gl.uniform3fv(uniform.location, uniform.value);
                                }
                            } else if (typeof uniform.value === 'number') {
                                gl.uniform1f(uniform.location, uniform.value);
                            } else if (uniform.value.r !== undefined) {
                                gl.uniform3f(uniform.location, uniform.value.r, uniform.value.g, uniform.value.b);
                            }
                        }
                    });
                    
                    // Draw geometry
                    if (this.geometry && this.geometry.draw) {
                        this.geometry.draw(gl);
                    }
                }
            },
            
            Triangle: class {
                constructor(gl) {
                    this.gl = gl;
                    
                    // Create triangle vertices
                    const vertices = new Float32Array([
                        -1, -1, 0, 0,
                         3, -1, 2, 0,
                        -1,  3, 0, 2
                    ]);
                    
                    this.buffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                }
                
                draw(gl) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                    
                    // Position attribute
                    const positionLocation = gl.getAttribLocation(gl.getParameter(gl.CURRENT_PROGRAM), 'position');
                    if (positionLocation >= 0) {
                        gl.enableVertexAttribArray(positionLocation);
                        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 16, 0);
                    }
                    
                    // UV attribute
                    const uvLocation = gl.getAttribLocation(gl.getParameter(gl.CURRENT_PROGRAM), 'uv');
                    if (uvLocation >= 0) {
                        gl.enableVertexAttribArray(uvLocation);
                        gl.vertexAttribPointer(uvLocation, 2, gl.FLOAT, false, 16, 8);
                    }
                    
                    gl.drawArrays(gl.TRIANGLES, 0, 3);
                }
            },
            
            Color: class {
                constructor(r, g, b) {
                    this.r = r;
                    this.g = g;
                    this.b = b;
                }
            }
        };
        
        console.log('Custom OGL-like API created');
    </script>

    <script>
        // Now create the actual FaultyTerminal effect
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, creating FaultyTerminal effect...');
            
            const container = document.getElementById('globe-background');
            if (!container) {
                console.error('Container not found!');
                return;
            }
            
            console.log('Container found, initializing FaultyTerminal...');
            
            try {
                // Create renderer
                const renderer = new window.OGL.Renderer({ dpr: Math.min(window.devicePixelRatio || 1, 2) });
                const gl = renderer.gl;
                
                // Vertex shader
                const vertexShader = `
                    attribute vec2 position;
                    attribute vec2 uv;
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = vec4(position, 0.0, 1.0);
                    }
                `;
                
                // Fragment shader (simplified version)
                const fragmentShader = `
                    precision mediump float;
                    varying vec2 vUv;
                    uniform float iTime;
                    uniform vec3 iResolution;
                    uniform float uBrightness;
                    uniform vec3 uTint;
                    
                    float hash21(vec2 p){
                        p = fract(p * 234.56);
                        p += dot(p, p + 34.56);
                        return fract(p.x * p.y);
                    }
                    
                    float noise(vec2 p) {
                        return sin(p.x * 10.0) * sin(p.y * (3.0 + sin(iTime * 0.3))) + 0.2; 
                    }
                    
                    float digit(vec2 p) {
                        vec2 grid = vec2(2.0, 1.0) * 15.0;
                        vec2 s = floor(p * grid) / grid;
                        p = p * grid;
                        
                        float intensity = noise(s * 0.1) * 1.3 - 0.03;
                        
                        p = fract(p);
                        p *= 1.5;
                        
                        float px5 = p.x * 5.0;
                        float py5 = (1.0 - p.y) * 5.0;
                        float x = fract(px5);
                        float y = fract(py5);
                        
                        float i = floor(py5) - 2.0;
                        float j = floor(px5) - 2.0;
                        float n = i * i + j * j;
                        float f = n * 0.0625;
                        
                        float isOn = step(0.1, intensity - f);
                        float brightness = isOn * (0.2 + y * 0.8) * (0.75 + x * 0.25);
                        
                        return step(0.0, p.x) * step(p.x, 1.0) * step(0.0, p.y) * step(p.y, 1.0) * brightness;
                    }
                    
                    void main() {
                        vec2 p = vUv * 1.5;
                        
                        // Scanlines
                        float bar = step(mod(p.y + iTime * 20.0, 1.0), 0.2) * 0.4 + 1.0;
                        
                        float middle = digit(p);
                        
                        const float off = 0.002;
                        float sum = digit(p + vec2(-off, -off)) + digit(p + vec2(0.0, -off)) + digit(p + vec2(off, -off)) +
                                    digit(p + vec2(-off, 0.0)) + digit(p + vec2(0.0, 0.0)) + digit(p + vec2(off, 0.0)) +
                                    digit(p + vec2(-off, off)) + digit(p + vec2(0.0, off)) + digit(p + vec2(off, off));
                        
                        vec3 baseColor = vec3(0.9) * middle + sum * 0.1 * vec3(1.0) * bar;
                        baseColor *= uTint;
                        baseColor *= uBrightness;
                        
                        gl_FragColor = vec4(baseColor, 1.0);
                    }
                `;
                
                // Create geometry and program
                const geometry = new window.OGL.Triangle(gl);
                const program = new window.OGL.Program(gl, {
                    vertex: vertexShader,
                    fragment: fragmentShader,
                    uniforms: {
                        iTime: { value: 0 },
                        iResolution: { value: new window.OGL.Color(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height) },
                        uBrightness: { value: 0.8 },
                        uTint: { value: new window.OGL.Color(0, 1, 0.25) } // Green tint
                    }
                });
                
                const mesh = new window.OGL.Mesh(gl, { geometry, program });
                
                // Resize function
                function resize() {
                    const width = container.offsetWidth;
                    const height = container.offsetHeight;
                    renderer.setSize(width, height);
                    program.uniforms.iResolution.value = new window.OGL.Color(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height);
                }
                
                // Animation loop
                function animate(time) {
                    program.uniforms.iTime.value = time * 0.001;
                    renderer.render({ scene: mesh });
                    requestAnimationFrame(animate);
                }
                
                // Setup
                resize();
                container.appendChild(gl.canvas);
                
                // Style the canvas
                gl.canvas.style.position = 'absolute';
                gl.canvas.style.top = '0';
                gl.canvas.style.left = '0';
                gl.canvas.style.width = '100%';
                gl.canvas.style.height = '100%';
                gl.canvas.style.zIndex = '0';
                
                // Start animation
                requestAnimationFrame(animate);
                
                // Handle resize
                const resizeObserver = new ResizeObserver(() => resize());
                resizeObserver.observe(container);
                
                console.log('FaultyTerminal effect initialized successfully!');
                
            } catch (error) {
                console.error('Error creating FaultyTerminal effect:', error);
            }
        });
    </script>
</body>
</html>
